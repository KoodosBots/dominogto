<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domino GTO Analyzer - Supabase Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="gto-engine.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            position: relative;
        }

        h1 {
            font-size: 3em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { filter: drop-shadow(0 0 20px rgba(102, 126, 234, 0.5)); }
            to { filter: drop-shadow(0 0 30px rgba(118, 75, 162, 0.8)); }
        }

        .auth-section {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 400px;
            margin: 0 auto 30px;
        }

        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-size: 0.9em;
            color: #a0a0a0;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        input, select {
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
        }

        .btn {
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .game-setup {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: none;
        }

        .setup-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .game-area {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .dominoes-section {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .dominoes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .domino {
            width: 60px;
            height: 120px;
            background: #f8f8f8;
            border: 2px solid #333;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .domino:hover {
            transform: scale(1.05);
            border-color: #667eea;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.3);
        }

        .domino.selected {
            background: linear-gradient(145deg, #667eea, #764ba2);
            border-color: #fff;
            transform: scale(1.1);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
        }

        .domino.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .domino-half {
            width: 100%;
            height: 45%;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            padding: 4px;
        }

        .pip {
            width: 6px;
            height: 6px;
            background: #000;
            border-radius: 50%;
            margin: auto;
        }

        .domino.selected .pip {
            background: #fff;
        }

        .domino-divider {
            width: 90%;
            height: 2px;
            background: #333;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .domino.selected .domino-divider {
            background: rgba(255, 255, 255, 0.7);
        }

        .board-section {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-height: 200px;
        }

        .board-display {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            align-items: center;
            min-height: 150px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            border: 2px dashed rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .board-display.drag-over {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        .board-domino {
            width: 50px;
            height: 100px;
            background: #f8f8f8;
            border: 2px solid #555;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 6px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease;
            cursor: pointer;
        }

        .board-domino:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        @keyframes slideIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }

        .hand-domino {
            width: 50px;
            height: 100px;
            background: #f8f8f8;
            border: 2px solid #444;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 6px;
            cursor: grab;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .hand-domino:hover {
            transform: translateY(-5px);
            border-color: #667eea;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.3);
        }

        .hand-domino.dragging {
            cursor: grabbing;
            opacity: 0.5;
        }

        .my-hand-section {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .my-hand-display {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 15px;
        }

        .stats-panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border-color: #667eea;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stat-label {
            color: #888;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .score-display {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            flex-wrap: wrap;
            gap: 15px;
        }

        .team-score {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            min-width: 150px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .team-score h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .score-value {
            font-size: 3em;
            font-weight: bold;
        }

        .analysis-section {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .suggestion {
            background: rgba(102, 126, 234, 0.1);
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
        }

        .probability-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .probability-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.5s ease;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: #1a1a1a;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            animation: modalSlide 0.3s ease;
        }

        @keyframes modalSlide {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .close-modal {
            float: right;
            font-size: 30px;
            color: #888;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-modal:hover {
            color: #fff;
        }

        .user-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
        }

        .user-info.active {
            display: block;
        }

        .selected-count {
            text-align: center;
            margin-top: 15px;
            font-size: 1.1em;
            color: #667eea;
        }

        .error-message {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #ef4444;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
            display: none;
        }

        .success-message {
            background: rgba(34, 197, 94, 0.1);
            border: 1px solid rgba(34, 197, 94, 0.3);
            color: #22c55e;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
            display: none;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .setup-grid {
                grid-template-columns: 1fr;
            }
            
            .dominoes-grid {
                grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            }
            
            .domino {
                width: 50px;
                height: 100px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Domino GTO Analyzer</h1>
            <p style="color: #888;">AI-Powered Strategy Analysis</p>
            <div class="user-info" id="userInfo">
                <span id="userEmail"></span> | 
                <button class="btn" style="padding: 5px 15px; font-size: 14px;" onclick="logout()">Logout</button>
            </div>
        </header>

        <!-- Auth Section -->
        <div class="auth-section" id="authSection">
            <h2 id="authTitle">Login</h2>
            <div class="error-message" id="authError"></div>
            <div class="success-message" id="authSuccess"></div>
            <form class="auth-form" id="authForm" onsubmit="handleAuth(event)">
                <div class="form-group">
                    <label for="email">Email</label>
                    <input type="email" id="email" required>
                </div>
                <div class="form-group">
                    <label for="password">Password</label>
                    <input type="password" id="password" required>
                </div>
                <button type="submit" class="btn" id="authSubmit">Login</button>
                <p style="text-align: center; margin-top: 15px;">
                    <span id="authToggleText">Don't have an account?</span>
                    <a href="#" onclick="toggleAuthMode()" style="color: #667eea;">
                        <span id="authToggleLink">Sign up</span>
                    </a>
                </p>
            </form>
        </div>

        <!-- Game Setup -->
        <div class="game-setup" id="setupScreen">
            <h2 style="margin-bottom: 20px;">Game Setup</h2>
            <div class="setup-grid">
                <div class="form-group">
                    <label for="gameType">Game Type</label>
                    <select id="gameType">
                        <option value="fives">Fives</option>
                        <option value="draw">Draw</option>
                        <option value="block">Block</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="scoreLimit">Score Limit</label>
                    <select id="scoreLimit">
                        <option value="100">100 Points</option>
                        <option value="150">150 Points</option>
                        <option value="250">250 Points</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="boneCount">Bones per Player</label>
                    <select id="boneCount">
                        <option value="7">7 Bones</option>
                        <option value="9">9 Bones</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="playerMode">Player Mode</label>
                    <select id="playerMode">
                        <option value="1v1">1 vs 1</option>
                        <option value="2v2">2 vs 2</option>
                    </select>
                </div>
            </div>
            <button class="btn" onclick="startGame()">Start Game</button>
        </div>

        <!-- Hand Selection -->
        <div class="game-area" id="handSelectionScreen">
            <div class="dominoes-section">
                <h3>Select Your Hand</h3>
                <div class="selected-count" id="selectedCount">Selected: 0 / 7</div>
                <div class="dominoes-grid" id="dominoesGrid"></div>
                <button class="btn" style="margin-top: 20px;" onclick="confirmHand()">Confirm Hand</button>
            </div>
        </div>

        <!-- Game Board -->
        <div class="game-area" id="gameBoardScreen">
            <div class="score-display">
                <div class="team-score">
                    <h3>Your Team</h3>
                    <div class="score-value" id="yourScore">0</div>
                </div>
                <div class="team-score">
                    <h3>Opponent Team</h3>
                    <div class="score-value" id="opponentScore">0</div>
                </div>
            </div>

            <div class="board-section" id="boardSection">
                <h3>Game Board</h3>
                <div class="board-display" id="boardDisplay">
                    <p style="color: #666;">No dominoes played yet. Drag from your hand or click 'Add to Board'.</p>
                </div>
                <div style="margin-bottom: 15px;">
                    <div style="display: flex; gap: 20px; align-items: center; margin-bottom: 10px;">
                        <div>
                            <label style="color: #888; font-size: 14px;">Analysis Mode:</label>
                            <select id="analysisSpeed" style="background: #1a1a1a; color: white; border: 1px solid #333; padding: 5px 10px; border-radius: 5px; margin-left: 10px;">
                                <option value="instant">⚡ Instant (Local backup while cloud processes)</option>
                                <option value="accurate">🎯 Most Accurate (Cloud AI only)</option>
                            </select>
                        </div>
                        <div>
                            <label style="color: #888; font-size: 14px;">Backup Depth:</label>
                            <select id="analysisTier" style="background: #1a1a1a; color: white; border: 1px solid #333; padding: 5px 10px; border-radius: 5px; margin-left: 10px;">
                                <option value="free">Quick (Depth: 2)</option>
                                <option value="basic">Medium (Depth: 5)</option>
                                <option value="pro">Deep (Depth: 10)</option>
                            </select>
                        </div>
                    </div>
                    <div style="font-size: 12px; color: #666; margin-left: 5px;">
                        💡 All analysis helps train our AI! Instant mode shows local analysis first, then upgrades to cloud AI results.
                    </div>
                </div>
                <div class="action-buttons">
                    <button class="btn" onclick="showAddToBoardModal()">Add to Board</button>
                    <button class="btn" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);" onclick="analyzePosition()">
                        AI Analysis
                    </button>
                    <button class="btn" style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);" onclick="endRound()">End Round</button>
                </div>
            </div>

            <div class="my-hand-section">
                <h3>My Hand</h3>
                <div class="my-hand-display" id="myHandDisplay"></div>
            </div>

            <div class="stats-panel">
                <h3>Game Statistics</h3>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="remainingBones">28</div>
                        <div class="stat-label">Bones in Boneyard</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="playedBones">0</div>
                        <div class="stat-label">Bones Played</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="drawsAndPasses">0/0</div>
                        <div class="stat-label">Draws / Passes</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="winProbability">
                            <span id="winProbValue">50</span>%
                        </div>
                        <div class="stat-label">AI Win Prediction</div>
                    </div>
                </div>
            </div>

            <div class="analysis-section" id="analysisSection" style="display: none;">
                <h3>AI Position Analysis</h3>
                <div id="analysisContent"></div>
            </div>
        </div>
    </div>

    <!-- Add to Board Modal -->
    <div class="modal" id="addToBoardModal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeAddToBoardModal()">&times;</span>
            <h3>Add Domino to Board</h3>
            <p>What happened?</p>
            <div style="display: flex; gap: 15px; justify-content: center; margin: 20px 0; flex-wrap: wrap;">
                <button class="btn" onclick="selectDominoSource('myHand')">I Played</button>
                <button class="btn" onclick="selectDominoSource('opponentHand')">Opponent Played</button>
                <button class="btn" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);" onclick="selectDominoSource('draw')">Someone Drew</button>
                <button class="btn" style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);" onclick="recordPass()">Someone Passed</button>
            </div>
            <div id="dominoSourceContent"></div>
        </div>
    </div>

    <script>
        // Initialize Supabase
        const SUPABASE_URL = 'https://azsnenvnqnchrlrtuocg.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF6c25lbnZucW5jaHJscnR1b2NnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTE4OTAzMjMsImV4cCI6MjA2NzQ2NjMyM30.hFDoOY00QbVRLBqmz6bzpVcK36sWF_VrO3XxElkJsCg';
        
        // Initialize client
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        // Game State
        let gameState = {
            gameType: 'fives',
            scoreLimit: 100,
            boneCount: 7,
            playerMode: '1v1',
            yourScore: 0,
            opponentScore: 0,
            hand: [],
            board: [],
            history: [],
            passes: 0,
            draws: 0,
            gameId: null,
            userId: null
        };

        // User State
        let currentUser = null;
        let authMode = 'login';

        // Check for existing session
        async function checkSession() {
            const { data: { user } } = await supabase.auth.getUser();
            
            if (user) {
                currentUser = user;
                showUserInfo();
                document.getElementById('authSection').style.display = 'none';
                document.getElementById('setupScreen').style.display = 'block';
            }
        }

        // Auth Functions
        function toggleAuthMode() {
            authMode = authMode === 'login' ? 'signup' : 'login';
            document.getElementById('authTitle').textContent = authMode === 'login' ? 'Login' : 'Sign Up';
            document.getElementById('authSubmit').textContent = authMode === 'login' ? 'Login' : 'Sign Up';
            document.getElementById('authToggleText').textContent = authMode === 'login' ? "Don't have an account?" : "Already have an account?";
            document.getElementById('authToggleLink').textContent = authMode === 'login' ? 'Sign up' : 'Login';
            hideMessages();
        }

        async function handleAuth(event) {
            event.preventDefault();
            hideMessages();
            
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            
            const authBtn = document.getElementById('authSubmit');
            authBtn.disabled = true;
            authBtn.innerHTML = 'Processing...<span class="loading"></span>';
            
            try {
                let result;
                
                if (authMode === 'login') {
                    result = await supabase.auth.signInWithPassword({ email, password });
                } else {
                    result = await supabase.auth.signUp({ email, password });
                }
                
                if (result.error) throw result.error;
                
                currentUser = result.data.user;
                
                // Create user profile if new signup
                if (authMode === 'signup') {
                    await supabase.from('user_profiles').insert({
                        user_id: currentUser.id,
                        email: currentUser.email,
                        username: email.split('@')[0]
                    });
                }
                
                showSuccess(authMode === 'login' ? 'Login successful!' : 'Registration successful!');
                
                setTimeout(() => {
                    document.getElementById('authSection').style.display = 'none';
                    document.getElementById('setupScreen').style.display = 'block';
                    showUserInfo();
                }, 1000);
                
            } catch (error) {
                showError(error.message);
            } finally {
                authBtn.disabled = false;
                authBtn.textContent = authMode === 'login' ? 'Login' : 'Sign Up';
            }
        }

        function showUserInfo() {
            document.getElementById('userEmail').textContent = currentUser.email;
            document.getElementById('userInfo').classList.add('active');
        }

        async function logout() {
            await supabase.auth.signOut();
            currentUser = null;
            location.reload();
        }

        function showError(message) {
            const errorEl = document.getElementById('authError');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
        }

        function showSuccess(message) {
            const successEl = document.getElementById('authSuccess');
            successEl.textContent = message;
            successEl.style.display = 'block';
        }

        function hideMessages() {
            document.getElementById('authError').style.display = 'none';
            document.getElementById('authSuccess').style.display = 'none';
        }

        // All possible dominoes
        const allDominoes = [];
        for (let i = 0; i <= 6; i++) {
            for (let j = i; j <= 6; j++) {
                allDominoes.push([i, j]);
            }
        }

        // Domino rendering functions
        function createDominoElement(values, clickHandler, className = 'domino') {
            const domino = document.createElement('div');
            domino.className = className;
            
            const topHalf = document.createElement('div');
            topHalf.className = 'domino-half';
            topHalf.appendChild(createPips(values[0]));
            
            const divider = document.createElement('div');
            divider.className = 'domino-divider';
            
            const bottomHalf = document.createElement('div');
            bottomHalf.className = 'domino-half';
            bottomHalf.appendChild(createPips(values[1]));
            
            domino.appendChild(topHalf);
            domino.appendChild(divider);
            domino.appendChild(bottomHalf);
            
            if (clickHandler) {
                domino.onclick = () => clickHandler(values, domino);
            }
            
            domino.dataset.top = values[0];
            domino.dataset.bottom = values[1];
            
            return domino;
        }

        function createPips(value) {
            const container = document.createDocumentFragment();
            const positions = getPipPositions(value);
            
            for (let i = 0; i < 9; i++) {
                const pip = document.createElement('div');
                pip.className = positions.includes(i) ? 'pip' : '';
                container.appendChild(pip);
            }
            
            return container;
        }

        function getPipPositions(value) {
            const pipLayouts = {
                0: [],
                1: [4],
                2: [0, 8],
                3: [0, 4, 8],
                4: [0, 2, 6, 8],
                5: [0, 2, 4, 6, 8],
                6: [0, 2, 3, 5, 6, 8]
            };
            
            return pipLayouts[value] || [];
        }

        // Game Functions
        async function startGame() {
            gameState.gameType = document.getElementById('gameType').value;
            gameState.scoreLimit = parseInt(document.getElementById('scoreLimit').value);
            gameState.boneCount = parseInt(document.getElementById('boneCount').value);
            gameState.playerMode = document.getElementById('playerMode').value;
            gameState.userId = currentUser.id;
            gameState.gameId = crypto.randomUUID();
            
            // Create game in Supabase
            await supabase.from('games').insert({
                id: gameState.gameId,
                user_id: gameState.userId,
                game_type: gameState.gameType,
                score_limit: gameState.scoreLimit,
                bone_count: gameState.boneCount,
                player_mode: gameState.playerMode,
                status: 'active'
            });
            
            document.getElementById('setupScreen').style.display = 'none';
            document.getElementById('handSelectionScreen').style.display = 'block';
            
            updateSelectedCount();
            displayDominoSelection();
        }

        function displayDominoSelection() {
            const grid = document.getElementById('dominoesGrid');
            grid.innerHTML = '';
            
            allDominoes.forEach(domino => {
                const element = createDominoElement(domino, (values, el) => toggleDominoSelection(values, el));
                grid.appendChild(element);
            });
        }

        function toggleDominoSelection(values, element) {
            const index = gameState.hand.findIndex(d => d[0] === values[0] && d[1] === values[1]);
            
            if (index === -1) {
                if (gameState.hand.length < gameState.boneCount) {
                    gameState.hand.push(values);
                    element.classList.add('selected');
                } else {
                    alert(`You can only select ${gameState.boneCount} dominoes!`);
                }
            } else {
                gameState.hand.splice(index, 1);
                element.classList.remove('selected');
            }
            
            updateSelectedCount();
        }

        function updateSelectedCount() {
            document.getElementById('selectedCount').textContent = 
                `Selected: ${gameState.hand.length} / ${gameState.boneCount}`;
        }

        async function confirmHand() {
            if (gameState.hand.length !== gameState.boneCount) {
                alert(`Please select exactly ${gameState.boneCount} dominoes!`);
                return;
            }
            
            // Record initial hand
            await recordGameState('hand_selected', { hand: gameState.hand });
            
            document.getElementById('handSelectionScreen').style.display = 'none';
            document.getElementById('gameBoardScreen').style.display = 'block';
            
            displayMyHand();
            setupBoardDropZone();
            updateStats();
        }

        function displayMyHand() {
            const handDisplay = document.getElementById('myHandDisplay');
            handDisplay.innerHTML = '';
            
            gameState.hand.forEach((domino, index) => {
                const element = createDominoElement(domino, null, 'hand-domino');
                
                element.draggable = true;
                element.dataset.handIndex = index;
                
                element.addEventListener('dragstart', handleDragStart);
                element.addEventListener('dragend', handleDragEnd);
                
                handDisplay.appendChild(element);
            });
        }

        // Drag and Drop
        let draggedDomino = null;

        function handleDragStart(e) {
            draggedDomino = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
        }

        function setupBoardDropZone() {
            const boardDisplay = document.getElementById('boardDisplay');
            
            boardDisplay.addEventListener('dragover', handleDragOver);
            boardDisplay.addEventListener('drop', handleDrop);
            boardDisplay.addEventListener('dragenter', handleDragEnter);
            boardDisplay.addEventListener('dragleave', handleDragLeave);
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDragEnter(e) {
            e.currentTarget.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            if (e.currentTarget === e.target) {
                e.currentTarget.classList.remove('drag-over');
            }
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            e.currentTarget.classList.remove('drag-over');
            
            if (draggedDomino && draggedDomino.classList.contains('hand-domino')) {
                const handIndex = parseInt(draggedDomino.dataset.handIndex);
                const domino = gameState.hand[handIndex];
                
                playDominoFromHand(domino);
            }
            
            return false;
        }

        // Game Actions
        function showAddToBoardModal() {
            document.getElementById('addToBoardModal').style.display = 'flex';
            document.getElementById('dominoSourceContent').innerHTML = '';
        }

        function closeAddToBoardModal() {
            document.getElementById('addToBoardModal').style.display = 'none';
        }

        function selectDominoSource(source) {
            const content = document.getElementById('dominoSourceContent');
            
            if (source === 'myHand') {
                content.innerHTML = '<h4>Select a domino from your hand:</h4>';
                const grid = document.createElement('div');
                grid.className = 'dominoes-grid';
                
                gameState.hand.forEach(domino => {
                    const element = createDominoElement(domino, (values) => {
                        playDominoFromHand(values);
                        closeAddToBoardModal();
                    });
                    grid.appendChild(element);
                });
                
                content.appendChild(grid);
            } else if (source === 'opponentHand') {
                content.innerHTML = `
                    <h4>Enter the domino your opponent played:</h4>
                    <div style="display: flex; gap: 20px; justify-content: center; align-items: center; margin: 20px 0;">
                        <input type="number" id="topValue" min="0" max="6" placeholder="Top" style="width: 60px; text-align: center;">
                        <span style="font-size: 24px;">|</span>
                        <input type="number" id="bottomValue" min="0" max="6" placeholder="Bottom" style="width: 60px; text-align: center;">
                    </div>
                    <button class="btn" onclick="addOpponentDomino()">Add to Board</button>
                `;
            } else if (source === 'draw') {
                content.innerHTML = `
                    <h4>Who drew from the boneyard?</h4>
                    <div style="display: flex; gap: 20px; justify-content: center; margin: 20px 0;">
                        <button class="btn" onclick="recordDraw('me')">I Drew</button>
                        <button class="btn" onclick="recordDraw('opponent')">Opponent Drew</button>
                    </div>
                `;
            }
        }

        async function playDominoFromHand(domino) {
            gameState.board.push(domino);
            gameState.hand = gameState.hand.filter(d => 
                !(d[0] === domino[0] && d[1] === domino[1])
            );
            
            gameState.passes = 0;
            displayMyHand();
            updateBoardDisplay();
            updateStats();
            
            if (gameState.gameType === 'fives') {
                calculateFivesScore('you');
            }
            
            await recordGameState('domino_played', { domino, player: 'you' });
        }

        async function addOpponentDomino() {
            const top = parseInt(document.getElementById('topValue').value);
            const bottom = parseInt(document.getElementById('bottomValue').value);
            
            if (isNaN(top) || isNaN(bottom) || top < 0 || top > 6 || bottom < 0 || bottom > 6) {
                alert('Please enter valid domino values (0-6)');
                return;
            }
            
            const domino = [top, bottom];
            gameState.board.push(domino);
            gameState.passes = 0;
            updateBoardDisplay();
            updateStats();
            closeAddToBoardModal();
            
            if (gameState.gameType === 'fives') {
                calculateFivesScore('opponent');
            }
            
            await recordGameState('domino_played', { domino, player: 'opponent' });
        }

        async function recordPass() {
            gameState.passes++;
            
            const playerCount = gameState.playerMode === '1v1' ? 2 : 4;
            if (gameState.passes >= playerCount) {
                alert('Game is blocked! Count points in hands.');
            }
            
            closeAddToBoardModal();
            updateStats();
            await recordGameState('pass');
        }

        function recordDraw(player) {
            gameState.draws++;
            
            if (player === 'me') {
                const content = document.getElementById('dominoSourceContent');
                content.innerHTML = `
                    <h4>What domino did you draw?</h4>
                    <div style="display: flex; gap: 20px; justify-content: center; align-items: center; margin: 20px 0;">
                        <input type="number" id="drawnTop" min="0" max="6" placeholder="Top" style="width: 60px; text-align: center;">
                        <span style="font-size: 24px;">|</span>
                        <input type="number" id="drawnBottom" min="0" max="6" placeholder="Bottom" style="width: 60px; text-align: center;">
                    </div>
                    <button class="btn" onclick="addDrawnToHand()">Add to Hand</button>
                `;
            } else {
                updateStats();
                recordGameState('draw', { player: 'opponent' });
                closeAddToBoardModal();
            }
        }

        async function addDrawnToHand() {
            const top = parseInt(document.getElementById('drawnTop').value);
            const bottom = parseInt(document.getElementById('drawnBottom').value);
            
            if (isNaN(top) || isNaN(bottom) || top < 0 || top > 6 || bottom < 0 || bottom > 6) {
                alert('Please enter valid domino values (0-6)');
                return;
            }
            
            gameState.hand.push([top, bottom]);
            displayMyHand();
            updateStats();
            closeAddToBoardModal();
            await recordGameState('draw', { player: 'you', domino: [top, bottom] });
        }

        function updateBoardDisplay() {
            const boardDisplay = document.getElementById('boardDisplay');
            boardDisplay.innerHTML = '';
            
            if (gameState.board.length === 0) {
                boardDisplay.innerHTML = '<p style="color: #666;">No dominoes played yet. Drag from your hand or click \'Add to Board\'.</p>';
            } else {
                gameState.board.forEach((domino, index) => {
                    const element = createDominoElement(domino, null, 'board-domino');
                    element.style.cursor = 'pointer';
                    element.onclick = () => removeDominoFromBoard(index);
                    element.title = 'Click to remove';
                    boardDisplay.appendChild(element);
                });
            }
        }

        function removeDominoFromBoard(index) {
            if (confirm('Remove this domino from the board?')) {
                gameState.board.splice(index, 1);
                updateBoardDisplay();
                updateStats();
            }
        }

        function calculateFivesScore(player = 'you') {
            let ends = [];
            if (gameState.board.length === 1) {
                ends = [gameState.board[0][0], gameState.board[0][1]];
            }
            // TODO: Implement proper end calculation for connected dominoes
            
            const sum = ends.reduce((a, b) => a + b, 0);
            if (sum % 5 === 0 && sum > 0) {
                if (player === 'you') {
                    gameState.yourScore += sum;
                    document.getElementById('yourScore').textContent = gameState.yourScore;
                } else {
                    gameState.opponentScore += sum;
                    document.getElementById('opponentScore').textContent = gameState.opponentScore;
                }
            }
        }

        function updateStats() {
            const totalDominoes = 28;
            const playedCount = gameState.board.length;
            const playerCount = gameState.playerMode === '1v1' ? 2 : 4;
            const totalInHands = gameState.boneCount * playerCount;
            const remainingInBoneyard = totalDominoes - playedCount - totalInHands - gameState.draws;
            
            document.getElementById('remainingBones').textContent = Math.max(0, remainingInBoneyard);
            document.getElementById('playedBones').textContent = playedCount;
            document.getElementById('drawsAndPasses').textContent = `${gameState.draws}/${gameState.passes}`;
        }

        // Initialize GTO Engine
        let gtoEngine = null;
        
        function initializeGTOEngine() {
            if (typeof DominoGTOEngine !== 'undefined') {
                gtoEngine = new DominoGTOEngine();
                console.log('GTO Engine initialized successfully');
            } else {
                console.error('DominoGTOEngine not available');
            }
        }

        // Smart AI Analysis - Always collects training data, optimizes for speed or accuracy
        async function analyzePosition() {
            const analysisSection = document.getElementById('analysisSection');
            const analysisContent = document.getElementById('analysisContent');
            const analysisSpeedSelect = document.getElementById('analysisSpeed');
            
            analysisSection.style.display = 'block';
            analysisContent.innerHTML = '<p>Analyzing position...</p>';
            
            const analysisMode = analysisSpeedSelect ? analysisSpeedSelect.value : 'instant';
            
            // Always send position data for training in background
            sendTrainingData();
            
            try {
                if (analysisMode === 'instant') {
                    // Show local analysis immediately, then upgrade with cloud results
                    await showInstantAnalysis();
                } else {
                    // Wait for most accurate cloud analysis
                    await showAccurateAnalysis();
                }
                
            } catch (error) {
                analysisContent.innerHTML = '<p style="color: #ef4444;">Analysis failed. Please try again.</p>';
                console.error('Analysis error:', error);
            }
        }

        // Instant mode: Show local analysis immediately, then upgrade
        async function showInstantAnalysis() {
            const analysisContent = document.getElementById('analysisContent');
            
            // Get local analysis first for instant feedback
            const localResult = await analyzeWithLocalGTO();
            localResult.method = 'Local GTO (Processing cloud AI...)';
            displayAnalysisResults(localResult);
            
            // Then get cloud analysis and upgrade the display
            try {
                const cloudResult = await analyzeWithSupabase();
                if (cloudResult) {
                    cloudResult.upgraded = true;
                    displayAnalysisResults(cloudResult);
                }
            } catch (error) {
                console.log('Cloud AI unavailable, keeping local analysis');
                // Keep local analysis, but update the method label
                localResult.method = 'Local GTO (Cloud AI unavailable)';
                displayAnalysisResults(localResult);
            }
        }

        // Accurate mode: Wait for cloud analysis only
        async function showAccurateAnalysis() {
            try {
                const cloudResult = await analyzeWithSupabase();
                if (cloudResult) {
                    displayAnalysisResults(cloudResult);
                } else {
                    // Fallback to local if cloud fails
                    const localResult = await analyzeWithLocalGTO();
                    localResult.method = 'Local GTO (Cloud AI unavailable)';
                    localResult.fallbackUsed = true;
                    displayAnalysisResults(localResult);
                }
            } catch (error) {
                // Fallback to local if cloud fails
                const localResult = await analyzeWithLocalGTO();
                localResult.method = 'Local GTO (Cloud AI unavailable)';
                localResult.fallbackUsed = true;
                displayAnalysisResults(localResult);
            }
        }

        // Background training data collection
        async function sendTrainingData() {
            try {
                // Send position data for training regardless of analysis mode
                const trainingData = {
                    position: {
                        board: gameState.board || [],
                        hand: gameState.hand || [],
                        gameType: gameState.gameType || 'fives',
                        scores: {
                            yours: gameState.yourScore || 0,
                            opponent: gameState.opponentScore || 0
                        },
                        passes: gameState.passes || 0,
                        draws: gameState.draws || 0
                    },
                    timestamp: Date.now(),
                    sessionId: gameState.gameId,
                    userId: gameState.userId
                };

                // Also include local GTO analysis as training signal
                if (gtoEngine) {
                    const localAnalysis = await analyzeWithLocalGTO();
                    trainingData.localGTOAnalysis = {
                        winProbability: localAnalysis.winProbability,
                        bestMove: localAnalysis.suggestions[0]?.title,
                        evaluation: localAnalysis.evaluation
                    };
                }

                // Send to Supabase for training (non-blocking)
                supabase.from('training_positions').insert(trainingData).then(result => {
                    if (result.error) {
                        console.log('Training data collection failed:', result.error);
                    } else {
                        console.log('Training data collected successfully');
                    }
                });

            } catch (error) {
                console.log('Training data collection error:', error);
            }
        }

        // Enhanced Supabase analysis function with caching
        async function analyzeWithSupabase() {
            // Initialize engine for caching if needed
            if (!gtoEngine) {
                initializeGTOEngine();
            }
            
            let positionHash = null;
            
            try {
                // Check cache first if GTO engine is available
                if (gtoEngine) {
                    positionHash = await gtoEngine.hashPosition(
                        gameState.board || [],
                        'player',
                        gameState.gameType || 'fives'
                    );
                    
                    const cachedResult = await gtoEngine.checkCache(positionHash, 99); // Special depth for Supabase cache
                    if (cachedResult && cachedResult.method === 'Cloud AI') {
                        return {
                            ...cachedResult,
                            fromCache: true
                        };
                    }
                }
                
                // Call Supabase for fresh analysis
                const { data, error } = await supabase.functions.invoke('analyze-domino-position', {
                    body: {
                        gameState: {
                            board: gameState.board,
                            hand: gameState.hand,
                            gameType: gameState.gameType,
                            scores: {
                                yours: gameState.yourScore,
                                opponent: gameState.opponentScore
                            },
                            remainingInBoneyard: parseInt(document.getElementById('remainingBones').textContent),
                            passes: gameState.passes,
                            draws: gameState.draws
                        }
                    }
                });
                
                if (error) throw error;
                
                const result = {
                    winProbability: data.winProbability,
                    suggestions: data.suggestions,
                    method: 'Cloud AI',
                    fromCache: false
                };
                
                // Cache the Supabase result using GTO engine
                if (gtoEngine && positionHash) {
                    await gtoEngine.storeAnalysis(positionHash, result, 99);
                }
                
                // Record analysis
                await recordGameState('analysis_requested', { analysis: data });
                
                return result;
                
            } catch (error) {
                console.error('Supabase analysis error:', error);
                return null;
            }
        }

        // Local GTO analysis function
        async function analyzeWithLocalGTO() {
            // Initialize engine if not already done
            if (!gtoEngine) {
                initializeGTOEngine();
            }
            
            if (!gtoEngine) {
                throw new Error('GTO Engine not available');
            }
            
            const selectedTier = document.getElementById('analysisTier')?.value || 'free';
            const startTime = Date.now();
            
            // Prepare game state for analysis
            const analysisGameState = {
                board: gameState.board || [],
                hand: gameState.hand || [],
                gameType: gameState.gameType || 'fives',
                yourScore: gameState.yourScore || 0,
                opponentScore: gameState.opponentScore || 0,
                passes: gameState.passes || 0,
                draws: gameState.draws || 0
            };
            
            // Run GTO analysis
            const analysis = await gtoEngine.analyzePosition(analysisGameState, selectedTier);
            const analysisTime = Date.now() - startTime;
            
            return {
                winProbability: analysis.winProbability,
                suggestions: analysis.suggestions,
                method: 'Local GTO',
                fromCache: analysis.fromCache,
                analysisTime: analysisTime,
                depth: analysis.depth || gtoEngine.tierLimits[selectedTier],
                tier: selectedTier
            };
        }

        // Display analysis results with method indicator and upgrade status
        function displayAnalysisResults(result) {
            const analysisContent = document.getElementById('analysisContent');
            const winProbElement = document.getElementById('winProbValue');
            
            // Update win probability
            if (winProbElement) {
                winProbElement.textContent = result.winProbability + '%';
            }
            
            // Method badges with smart coloring
            let methodBadge;
            if (result.method.includes('Cloud AI')) {
                methodBadge = '<span style="background: #3b82f6; padding: 2px 8px; border-radius: 12px; font-size: 11px;">☁️ Cloud AI</span>';
            } else if (result.method.includes('Processing')) {
                methodBadge = '<span style="background: #f59e0b; padding: 2px 8px; border-radius: 12px; font-size: 11px;">⚡ Local GTO</span>';
            } else {
                methodBadge = '<span style="background: #10b981; padding: 2px 8px; border-radius: 12px; font-size: 11px;">⚡ Local GTO</span>';
            }
            
            const cacheIndicator = result.fromCache ? 
                '<span style="color: #10b981; font-size: 12px;">📦 Cached</span>' : 
                '<span style="color: #f59e0b; font-size: 12px;">🔄 Fresh</span>';
            
            // Special indicators
            const upgradeNotice = result.upgraded ? 
                '<div style="color: #10b981; font-size: 12px; margin-top: 5px;">✨ Upgraded to Cloud AI analysis!</div>' : '';
            
            const fallbackNotice = result.fallbackUsed ? 
                '<div style="color: #f59e0b; font-size: 12px; margin-top: 5px;">⚠️ Cloud AI unavailable, using local analysis</div>' : '';
                
            const trainingNotice = '<div style="color: #8b5cf6; font-size: 12px; margin-top: 5px;">📊 Position data sent for AI training</div>';
            
            // Build analysis details section
            let analysisDetails = `
                <div style="margin-bottom: 15px; padding: 10px; background: #1a1a1a; border-radius: 5px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div style="display: flex; gap: 10px; align-items: center;">
                            ${methodBadge}
                            ${cacheIndicator}
                        </div>
                    </div>
                    <div style="font-size: 13px; color: #ccc; margin-bottom: 5px;">
                        ${result.method}
                    </div>
            `;
            
            // Add performance details for local GTO
            if (result.method.includes('Local GTO') && result.tier) {
                analysisDetails += `
                    <div style="font-size: 12px; color: #666;">
                        Depth: ${result.depth} moves | 
                        Time: ${result.analysisTime}ms | 
                        Quality: ${result.tier?.toUpperCase()}
                    </div>
                `;
            }
            
            analysisDetails += upgradeNotice + fallbackNotice + trainingNotice + '</div>';
            
            // Display suggestions
            const suggestionsHtml = result.suggestions.map(s => `
                <div class="suggestion">
                    <h4>${s.title}</h4>
                    <p>${s.description}</p>
                    <div class="probability-bar">
                        <div class="probability-fill" style="width: ${s.confidence}%"></div>
                    </div>
                    <small>Confidence: ${s.confidence}%</small>
                </div>
            `).join('');
            
            analysisContent.innerHTML = analysisDetails + suggestionsHtml;
        }

        // Record game state for training
        async function recordGameState(action, additionalData = {}) {
            try {
                await supabase.from('game_states').insert({
                    game_id: gameState.gameId,
                    user_id: gameState.userId,
                    action,
                    board_state: gameState.board,
                    hand_state: gameState.hand,
                    scores: {
                        yours: gameState.yourScore,
                        opponent: gameState.opponentScore
                    },
                    metadata: {
                        ...additionalData,
                        gameType: gameState.gameType,
                        playerMode: gameState.playerMode,
                        passes: gameState.passes,
                        draws: gameState.draws
                    }
                });
            } catch (error) {
                console.error('Failed to record game state:', error);
            }
        }

        async function endRound() {
            await recordGameState('round_ended', {
                finalScores: {
                    yours: gameState.yourScore,
                    opponent: gameState.opponentScore
                }
            });
            
            alert('Round ended! Calculating scores...');
            
            gameState.board = [];
            gameState.hand = [];
            updateBoardDisplay();
            displayMyHand();
            
            if (gameState.yourScore >= gameState.scoreLimit || gameState.opponentScore >= gameState.scoreLimit) {
                await endGame();
            } else {
                document.getElementById('gameBoardScreen').style.display = 'none';
                document.getElementById('handSelectionScreen').style.display = 'block';
                displayDominoSelection();
            }
        }

        async function endGame() {
            const winner = gameState.yourScore >= gameState.scoreLimit ? 'You' : 'Opponent';
            
            await supabase.from('games').update({
                status: 'completed',
                winner,
                final_scores: {
                    yours: gameState.yourScore,
                    opponent: gameState.opponentScore
                },
                completed_at: new Date()
            }).eq('id', gameState.gameId);
            
            alert(`Game Over! ${winner} won!`);
            
            // Reset
            gameState = {
                gameType: 'fives',
                scoreLimit: 100,
                boneCount: 7,
                playerMode: '1v1',
                yourScore: 0,
                opponentScore: 0,
                hand: [],
                board: [],
                history: [],
                passes: 0,
                draws: 0,
                gameId: null,
                userId: currentUser.id
            };
            
            document.getElementById('gameBoardScreen').style.display = 'none';
            document.getElementById('setupScreen').style.display = 'block';
        }

        // Initialize
        window.onload = function() {
            checkSession();
            initializeGTOEngine();
        };

        // Modal close
        window.onclick = function(event) {
            const modal = document.getElementById('addToBoardModal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        };
    </script>
</body>
</html>